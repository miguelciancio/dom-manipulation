DOM Course

What is DOM?

DOM stands for Document Object Model. DOM is a built-in that has many properties and methods that we can use to manipulate the content, the structure and the style of a project, which is one of the most unique and useful abilities in JavaScript.

Another way to think about DOM is as a tree. You have the first element of your tree - called root - gives "birth" to the rest of the elements. So, most of the elements of your tree - diagram - have a parent-child-sibling relationship
Ex.:

		                 Document
	                          	         |
	______________Element <html>______________
	|					|
	|					|
            Element                                                                           Element 
            <head>				            <body>
	|					|
	|					|
       	|         		                                        ---------------------------
	|                                                                           |                                |
	|			                      |                                |
            Element                       Class Attribute -------- Element                    Element 
              <title>		"className" 	<p>	                <h1>
	|			                     |                                 |
	|			                     |                                 |
         Text: 'This is 			                 Text:  	               Text: 
           my website'			        'My Paragraph'           'My Header'

So, basically, the top most node "Document" on the tree above is  the root node of the dom tree which we use access the dom and manipulate all of the content.
Now, this 'document' node has only one child node which is the 'html' element and the 'html' is a parent node to the 'head' and 'body' element.
Now, the 'head' and 'body' elements are what you would call siblings since they are on the same level in the dom tree.
Underneath the 'head' element you see it has only one child node which is the 'title' element and the text underneath the title is a child node of the 'title' element. These relationships also applied to the other side of the dom tree, under the 'body' element.
So, the 'body' element is the parent of the 'paragraph' and 'h1' whose are siblings to each other. The text contents inside each of these elements are trial nodes to the 'paragraph' and 'h1', which basically are child nodes to them.
Now, next to the 'paragraph' element you could see a class attribute and html attributes such as ids or classes are also considered as nodes in the dom hierarchy. However, they don't actually participate in this parent-child-sibling relationship like the other nodes do. Therefore, the way to access them is through properties of the element node that they are contained in.


1 - SELECTING ELEMENTS IN THE DOM:

Basically, the're a couple of way to select any element in your dom tree:
. getElementById() ---> As the name suggest, you literally capture the element by his id. Keep in mind that on html5 id must be unique. That means, you can't have more than 1 element with the same id.

. getElementByClassName() ---> This way you can get the element or all the elements that have the same class name. You could have more than one element with the same class name, so that is the reason for this thing happens.

. getElementsByTagName() ---> With this method, you can get all the elements with the same tag. That means if you have tons of paragraphs in your html file and you want to capture all of them at once, you should use this method here becausa that is exactly what is going to do.

. querySelector() ---> This one is used to select ONLY ONE item or the FIRST item that matches the select has given. So, if you have multiple items with the same tag, class names or eve the same id, it will select the first one it comes across. So, the beauty of this method is that you can select ANY element across your html/css file.

. querySelectorAll() ---> This method is pretty much similar with the previously one but instead of be limited to select only one element, here you can select multiples elements. Let's say that you have 12 div in your html file and you wanto to select them all at once. So, with this method you can do it.


2 - STYLING AN ELEMENT:

In order to change the style of an element, first-of-all you must get the element by one of the various current methods on JS and storage this element on a variable. After that, you will be able to access it by typing the command '.style' after the variable.
Ex.:
	const title = window.document.querySelector('h1');
	title.style.color = 'red';

This method is called in-line style this is probably the most direct method to do it. Of course, there are another methods to style an element by JS.

OBS: A quickly remind: CSS properties are written in Camel Case and not with a more standard snake case which has the dash, so the Camel Case is essentially just a capitle letter to begin the second word  and any subsequent word in the name or method or even a property.
Ex.:
	CSS --> font-size = 1.2em;
	JS    --> fontSize = 1.2em;


3 - CREATING AN ELEMENT:
It is very easy and simple to create ANY html element with JS.
Ex.:
	// CREATE THE ELEMENTS.
	const ul = window.document.querySelector('ul');
	const li = window.document.createElement('li');

	// ADD THE ELEMENTS
	ul.append(li);

		
4 - MODIFY TEST:
It is important to note that there are a couple of way to include/modify text on your html element and those ways are 'innerTEXT', 'textContent' and 'innerHTML'.
So the difference among them is that the 'innerText' simply get the visible text contained inside that node. With 'textContent' it's actually display the same way it is in the html file, so it's got all those indents and it's jumping onto a new line and with 'innerHTML' a similar sort of thing with the indents and jumping on new lines but it's also showing the tags.
Now, there is a bit of danger using 'innerHTML' and that is mainly a security issues. You don't really want user input to be displayed in the 'innerHTML' because this actually allows user to control the javascript and html on your web page which obviously has its problems there.
Ex.:
	li.innerText = 'X-men';


5 - MODIFYING ELEMENTS ATTRIBUTE & CLASSES:
There are several ways to do it and the first method that you are taking a look at is the setAttribute().
Ex.:
	// MODIFYNG ATTRIBUTE
	li.setAttribute('id', 'main-heading');

Now, you are taking a look on how to remove the created/existed attribute on a HTML element.
Ex.:
	// REMOVING ATTRIBUTE
	li.removeAttribute('id');

There is another way to create an element's attribute.
Ex.:
	const title = window.document.querySelector('#main-heading');
	title.getAttribute('id);

Now let's see how to deal with classes. In order to do it you are going to the property 'classList'. This property has a quite few ways to utilise it and let's see them all. The first way is simple the method '.add'.
Ex.:
	li.classList.add('list-items');

Now another thing you could find out is wheter an element has that specific class by the method contained.
Ex.:
	console.log(li.classList.contains('list-items));



6 - REMOVE ELEMENTS;
It is very simple to do it, all you have to do is to use the method '.remove()' after the element you want.
Ex.:
	li.remove()



7 - TRAVERSING THE DOM:
Traverse DOM is the act of selecting an element from another element and we use this method because it is always easier to move from an element to another rathern than you use 'document.querySelector()' method.

Now, often there will be times where tou want to move through the dom without specifying each and every element or node beforehand, so learning how to traverse the dom tree is essential to understanding how to work with JavaScript and html.

So, there are a few ways to traverse the dom tree. The first method to identifying the parent node of an element is the method '.parentNode' or '.parentElement' - commonly known as traverse upwards.
Ex.:
	let ul = window.document.querySelector('ul');
	console.log(ul.parentNode);
	console.log(ul.parentElement);

Now, when you do that you literally find out the first level above of the node you are working. Let's say that your node has a grand parent, how do you get it? Simple, just need to put another '.parentNode' or '.parentElement' after the first one so that way you will get the Element above.
Ex.:
	let ul = window.document.querySelector('ul')
	console.log(ul.parentNode.parentNode);
	console.log(ul.parentElement.parentElement.parentElement);

So, the '.parentNode' or '.parentElement' is a property that lets you select the parent element. The parent element is the element that encloses the current element. It is great for selecting one level upwards.

Difference:
'.parentElement' returns null if the parent is not an element node, that is the main difference between '.parentElement' and '.parentNode'. In many cases one can use anyone of them, in most cases, they are the same. 
Ex.:
	// returns the document node
	document.documentElement.parentNode; 

	// returns null
	document.documentElement.parentElement; 

The HTML element (document.documentElement) doesnâ€™t have a parent that is an element, it is a node, therefore, the parent element is null.

Now let's take a look at how you can traverse downwards in the dom tree by taking a look at the child node traversals in the dom tree.

It is pretty much works similar as the upwards traverse and the difference lays on the name of the property: '.childNode' and '.childElement'.
Ex.:
	let ul = window.document.querySelector('ul');
	console.log(ul.childNodes);  //  return the first level node after this one.
	console.log(ul.firstChild);  //  return the first child element of the first level node after this one.
	console.log(ul.lastChild);  //  return the last child element of the first level node after this one.

	ul.childNodes[1].style.backgroundColor = 'blue';  //  return blue background color.

Now, in case of you want to select ONLY the elements nodes you have the '.children' property. In that case, you won't select anything else apart of the elements.
Ex.:
	console.log(ul.children);
	console.log(ul.firstElementChild);	
	console.log(ul.lastElementChild);

So, the '.children' is a property that lets you select direct descendants (elements that are immediately nested in another element). It returns a HTML Collection that updates when children elements are changed. 
Ex.:
	<ul class="list">
  		<li><a href="#">Link 1</a></li>
		<li><a href="#">Link 2</a></li>
		<li><a href="#">Link 3</a></li>
		<li><a href="#">Link 4</a></li>
		<li><a href="#">Link 5</a></li>
	</ul>	

	const list = document.querySelector('.list');
	const listItems = list.children;

	console.log(listItems);
	

A HTML Collection is similar to a NodeList (that querySelectorAll returns). What matters is - a HTML collection is an array-like object. If you want to loop over it with 'Array.prototype.forEach', you need to convert it into an array with 'Array.from first'.
Ex.:
	const array = Array.from(HTMLCollection)
	array.forEach(el => { /* do whatever you want */})

Now, lest's take a look at your sibling no traverse. So, just to reassure, siblings are node elements that are at the same node level. It is important to note that sibling don't have to be the same type of node.

Once again, you have propreties for nodes which covers all the nodes and you also have properties which covers only elements nodes.
Ex.:
	let ul = window.document.querySelector('ul');
	console.log(ul.previousSibling);
	console.log(nextSibling);


8 - EVENT LISTENERS:
Event listeners are among the most frequently used JavaScript structures in web design and what they do is basically just allow us to add interactive functionality to html elements by listening to different events that take place on the page, such as when a user presses a key or when elements loads or when a user clicks a button.
Now, the most common events you might listen out for are load events, touch start events, key down events, mouseover events and of course click events.
Here we are going to take a look on the two most common ways you can add event listeners in your. The first way you can include an event is actually inside of your html file and idrectly inside one of these elements. 
So, what this event is the global on event attribute and this way of creating an event to an element works pretty much like any attribute you insert it directly into the html element that's present on the page or the element you want to apply the event to and then apply a one0liner script to that particular element.
Ex.:
	<button onclick="window.alert('I Love JavaScript')"

So, that is the first way to include an event in your project which is just direct into the html on that element you will apply the event to.

Now, the next method to create an event listener is the JavaScript 'adEventListener()' method and the way this method works is first include an element that we want to apply the event listener to. Inside the brackets you must include the type of event you want to create and then after this the second parameter is the function you want to fire off and then you also have an option here for a third parameter, which will take in a boolean data type so true or false and this is in relation to bubbling and capturing.
Ex.:
	window.document.addEventListener("click", function);

Now, generally people do tend to use the '.addEventListener()' method more than the html on event method typically because you can apply as many event listeners to an element through the '.addEventListener()' whereas with the html on event method you can only apply it once so if you had one event already on a html element and then you try to apply another one and that new one would override the old one. However, again if you only want to apply one event the on event method works perfectly fine so.
Ex.:
	on event ---> onclick, etc.



9 - EVENT LISTENERS EXAMPLE:
Here, you will se a simple example of event listener when you click a button and then you show or hide a HTML element. Basically, let's assume that you have a div with a class called container and inside of that div you have got a a button element which has a class of reveal-btn. Underneath that you've got another div of class hidden-content which is the one you will hide and show.

Now the first thing you want to do is go to your JS file and create two constants so you can grab these two elements: reveal-btn and hidden-content.
Ex.:
	const revealBtn = window.document.querySelector('.reveal-btn');
	const hiddenContent = window.document.querySelector (.hidden-content');

Now, the next thing you want to do now is create a callback function which will check if our hidden content here has the class of reveal-btn.
Ex.:
	function revealContent () {
		// how to read it - If the hiddenContent - grab the class name - contains reveal-btn:
		if (hiddenContent.classList.contains('reveal-btn') {
			hiddenContent.classList.remove('reveal-btn');
		} else {
			hiddenContent.classList.add('reveal-btn');
		}
	}

So, basically what this callback function do is check if your hidden-content div contains a class of reveal-btn - for instance, class = 'hidden-content.reveal-btn' -  the function will remove the '.reveal-btn' from the name of the class. In case of false, the function will add the '.reveal-btn' to the name of the class.

Now, the next thing you wanna do now is include your event listeners. So, you want to apply your event listeners in your button.
Ex.:
	revealBtn.addEventListener('click', revealContent);

This action allows you to hide or show the content.

And the last thing you will do now is visually hide your div which has the dummy test. So you do that inside your style sheet.
Ex.:
	.hidden-content {
		display: none;
	}
	
	.hidden-content.reveal-btn {
		display: block;
	}

So, what you are essentially sayong here is that depending on the current state of your 'hidden-content', JavaScript will either add or remove the '.reveal-btn' class.

So, that is how you can create really basic reveal hard functionality using event listeners which looks pretty simple but this technique actually can be used for maniy different things, such as toggling a menu on small screens so when you see that hamburguer menu or you can display error messages with this and many more things.

Now, this is actually just scratching at the surface of event listeners and there are some things lurking underneath or more appropriately put lurking behind the scenes of event listeners, and that is event propagation and event delegation.



10 - EVENT PROPAGATION:
Now, event propagation refers to how an event travels through the document object model (DOM tree) and you can think of event propagation as electricity running through a wire until it reaches its destination.

Now, you are fully aware the dom tree is full of nodes and when you referring to event propagation and events the event needs to pass through every node on the 



















